
-- tripplemagic : Int -> Int -> Int -> Int;
-- tripplemagic x y z = ((\x:Int. x+x) x) + y + z;
-- main : Int;
-- main = tripplemagic ((\x:Int. x+x+3) ((\x:Int. x) 2)) 5 3
-- answer: 22

-- apply : (Int -> Int) -> Int -> Int;
-- apply f x = f x;
-- main : Int;
-- main = apply (\x : Int . x + 5) 5
-- answer: 10

-- apply : (Int -> Int -> Int) -> Int -> Int -> Int;
-- apply f x y = f x y;
-- krimp: Int -> Int -> Int;
-- krimp x y = x + y;
-- main : Int;
-- main = apply (krimp) 2 3;
-- answer: 5

fibbonaci : Int -> Int;
fibbonaci x = case x of {
    0 => 0,
    1 => 1,
    -- abusing overflows to represent negatives like a boss
    _ =>   (fibbonaci (x - 2))
         + (fibbonaci (x - 1))
} : Int;


main : Int;
main = fibbonaci 10;
-- answer: 55
