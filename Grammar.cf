
Program. Program ::= [Def] ;

DBind. Def ::= Bind ;
DData. Def ::= Data ;
separator Def ";" ;

Bind. Bind ::= Ident ":" Type ";"
               Ident [Ident] "=" Exp ;

Data. Data ::= "data" Type "where" "{"
               [Constructor] "}" ;

separator nonempty Constructor "" ;

Constructor. Constructor ::= Ident ":" Type ;

TMono.   Type1 ::= "_" Ident ;
TPol.    Type1 ::= "'" Ident ;
TConstr. Type1 ::= Ident "(" [Type] ")" ; 
TArr.    Type  ::= Type1 "->" Type ;

EAnn.   Exp5 ::= "(" Exp ":" Type ")" ;
EId.    Exp4 ::= Ident ;
ELit.   Exp4 ::= Literal ;
EApp.   Exp3 ::= Exp3 Exp4 ;
EAdd.   Exp1 ::= Exp1 "+" Exp2 ;
ELet.   Exp  ::= "let" Ident "=" Exp "in" Exp ; 
EAbs.   Exp  ::= "\\" Ident "." Exp ;
ECase.  Exp  ::= "case" Exp "of" "{" [Inj] "}";

LInt. Literal ::= Integer ;

Inj. Inj ::= Init "=>" Exp ;
separator nonempty Inj ";" ;

InitLit. Init    ::= Literal ;
InitConstr. Init ::= Ident [Ident] ;
InitCatch. Init  ::= "_" ;

separator Type " " ;
coercions Type 2 ;

-- This doesn't seem to work so we'll have to live with ugly keywords for now
-- token Poly upper (letter | digit | '_')* ;
-- token Mono lower (letter | digit | '_')* ;

separator Ident " ";

coercions Exp 5 ;

comment "--" ;
comment "{-" "-}" ;

